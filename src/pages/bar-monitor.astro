---
import Layout from "../layouts/Layout.astro";

type OrderLine = {
  id: number;
  name: string;
  qty: number;
  price_unit: number;
  order_id: number;
};
type Order = {
  id: number;
  name: string;
  date_order: string;
  amount_total: number;
  partner_name?: string;
  note?: string;
  lines: OrderLine[];
};

const ODOO_URL = "http://localhost:8069/jsonrpc";
const ODOO_DB = "restaurant";
const ODOO_UID = 2;
const ODOO_PASSWORD = "Nhan@2025";

async function odooRpc(model: string, method: string, args: any[], kwargs: Record<string, any> = {}) {
  const res = await fetch(ODOO_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      method: "call",
      params: {
        service: "object",
        method: "execute_kw",
        args: [ODOO_DB, ODOO_UID, ODOO_PASSWORD, model, method, args, kwargs],
      },
      id: Date.now(),
    }),
  });
  const json = await res.json();
  if (json.error) {
    console.error("Odoo RPC Error:", json.error);
    throw new Error(json.error.data?.message || json.error.message);
  }
  return json.result;
}

function extractBarHint(note?: string): string | null {
  if (!note) return null;
  const lower = note.toLowerCase();
  const start = lower.indexOf("[quầy nước / bar]");
  if (start === -1) return null;
  const barBlock = note.slice(start);
  const bbLower = barBlock.toLowerCase();
  const hintIndex = bbLower.indexOf("hinweis:");
  if (hintIndex === -1) return null;
  let after = barBlock.slice(hintIndex + "hinweis:".length);
  after = after.replace(/<[^>]*>/g, "").trim();
  return after || null;
}

async function fetchOrders(): Promise<Order[]> {
  try {
    const ordersRaw = await odooRpc("sale.order", "search_read", [[["state", "in", ["draft", "sent"]]]], {
      fields: ["id", "name", "date_order", "amount_total", "partner_id", "note", "order_line"],
      order: "id desc",
      limit: 20,
    });

    if (!Array.isArray(ordersRaw) || ordersRaw.length === 0) return [];

    const allLineIds: number[] = [];
    for (const o of ordersRaw) {
      if (Array.isArray(o.order_line)) {
        for (const lid of o.order_line) {
          if (!allLineIds.includes(lid)) allLineIds.push(lid);
        }
      }
    }

    let linesByOrder: Record<number, OrderLine[]> = {};
    if (allLineIds.length > 0) {
      const linesRaw = await odooRpc("sale.order.line", "search_read", [[["id", "in", allLineIds]]], {
        fields: ["id", "name", "product_uom_qty", "price_unit", "order_id", "product_id"],
      });

      const productIds: number[] = [];
      for (const l of linesRaw as any[]) {
        const prodId = Array.isArray(l.product_id) ? l.product_id[0] : l.product_id;
        if (prodId && !productIds.includes(prodId)) productIds.push(prodId);
      }

      const categoryByProduct: Record<number, string> = {};
      if (productIds.length > 0) {
        const productsRaw = await odooRpc("product.product", "read", [productIds, ["categ_id"]]);
        for (const p of productsRaw as any[]) {
          const catName = Array.isArray(p.categ_id) ? p.categ_id[1] : "";
          categoryByProduct[p.id] = (catName || "").toLowerCase();
        }
      }

      for (const l of linesRaw as any[]) {
        const orderId = Array.isArray(l.order_id) ? l.order_id[0] : l.order_id;
        const prodId = Array.isArray(l.product_id) ? l.product_id[0] : l.product_id;
        const catNorm = (categoryByProduct[prodId] || "").toLowerCase();
        if (!catNorm.includes("bar")) continue;

        if (!linesByOrder[orderId]) linesByOrder[orderId] = [];
        linesByOrder[orderId].push({
          id: l.id,
          name: l.name,
          qty: l.product_uom_qty,
          price_unit: l.price_unit,
          order_id: orderId,
        });
      }
    }

    const orders: Order[] = (ordersRaw as any[]).map((o) => ({
      id: o.id,
      name: o.name,
      date_order: o.date_order,
      amount_total: o.amount_total,
      partner_name: Array.isArray(o.partner_id) ? o.partner_id[1] : "Gast",
      note: o.note,
      lines: linesByOrder[o.id] || [],
    }));

    return orders.filter((o) => o.lines.length > 0);
  } catch (err) {
    console.error("Fehler beim Laden der Bestellungen (Bar):", err);
    return [];
  }
}

const orders = await fetchOrders();

// Dữ liệu để in – an toàn 100% nhờ define:vars
const printData = orders.map(o => ({
  id: o.id,
  name: o.name,
  lines: o.lines.map(l => ({ name: l.name, qty: l.qty })),
  hinweis: extractBarHint(o.note) || "",
}));
---
<Layout title="Barmonitor – Getränke-Bestellungen">
  <div class="page">
    <header class="header">
      <div>
        <h1>Barmonitor</h1>
        <p>Online-Getränke (Odoo: sale.order – draft/sent, Bereich BAR)</p>
      </div>
      <div class="status-box">
        <span class="dot"></span>
        <span>
          {orders.length} offene Bestellung{orders.length === 1 ? "" : "en"}
        </span>
      </div>
    </header>

    <main class="main">
      {orders.length === 0 ? (
        <div class="no-orders">
          <p>Aktuell keine offenen Bar-Bestellungen.</p>
        </div>
      ) : (
        <div class="orders-grid">
          {orders.map((o) => (
            <article class="order-card">
              <header class="order-header">
                <div>
                  <h2>{o.name}</h2>
                  <p class="order-meta">
                    {o.partner_name ? o.partner_name : "Gast"} ·{" "}
                    {new Date(o.date_order).toLocaleString("de-DE")}
                  </p>
                </div>
                <div class="order-badge">BAR</div>
              </header>
              <ul class="order-lines">
                {o.lines.map((l) => (
                  <li class="order-line">
                    <span class="line-qty">{l.qty}×</span>
                    <span class="line-name">{l.name}</span>
                    <span class="line-price"></span>
                  </li>
                ))}
              </ul>
              {extractBarHint(o.note) && (
                <div class="order-note">
                  <strong>Hinweis:</strong>
                  <div class="order-note-html">
                    {extractBarHint(o.note)}
                  </div>
                </div>
              )}
            </article>
          ))}
        </div>
      )}
    </main>
  </div>

  <!-- IN TỰ ĐỘNG BAR – SIÊU ỔN ĐỊNH, KHÔNG MISS, KHÔNG TRÙNG -->
  <script define:vars={{ printData }}>
    const KEY = "lastPrintedBarId_v2025";
    const getLast = () => Number(localStorage.getItem(KEY) || "0");
    const setLast = (id) => localStorage.setItem(KEY, String(id));
    let isPrinting = false;
    const delay = (ms) => new Promise(res => setTimeout(res, ms));

    console.log("%cBAR MONITOR TẢI LẠI", "color:#22c55e;font-size:16px;font-weight:bold");
    console.log("Thời gian:", new Date().toLocaleString("vi-VN"));
    console.log("Tổng đơn BAR:", printData.length);
    console.log("ID cao nhất:", printData.length ? Math.max(...printData.map(o => o.id)) : "không có");
    console.log("lastPrintedBarId lưu trước =", getLast());

    const printNewOrders = async () => {
      if (isPrinting) return;
      isPrinting = true;

      const lastId = getLast();
      let highestId = lastId;
      const ordersToPrint = [];

      for (const order of printData) {
        if (order.id > lastId) {
          ordersToPrint.push(order);
          if (order.id > highestId) highestId = order.id;
        }
      }

      if (ordersToPrint.length === 0) {
        console.log("%cKhông có đơn BAR mới", "color:#22c55e");
      } else {
        console.log(`%cCó ${ordersToPrint.length} đơn BAR mới → đang in...`, "color:#22c55e;font-weight:bold");
      }

      for (const order of ordersToPrint) {
        let success = false;
        let attempts = 0;
        while (!success && attempts < 5) {
          try {
            const res = await fetch("http://localhost:9100/print", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                type: "bar",                    // ← quan trọng: type = "bar"
                orderName: order.name,
                items: order.lines,
                hinweis: order.hinweis.trim()
              })
            });
            if (res.ok) {
              success = true;
              console.log(`In BAR THÀNH CÔNG: ${order.name} (ID: ${order.id})`);
            } else throw new Error("Not 200");
          } catch (e) {
            attempts++;
            console.warn(`Lỗi in BAR lần ${attempts}/5 – ${order.name}`, e);
            if (attempts < 5) await delay(2000 * attempts);
          }
        }
        if (!success) console.error(`IN BAR THẤT BẠI HOÀN TOÀN: ${order.name}`);
      }

      if (highestId > lastId) {
        setLast(highestId);
        console.log(`%cĐÃ CẬP NHẬT lastPrintedBarId → ${highestId}`, "color:#22c55e;font-weight:bold");
      }

      if (ordersToPrint.length > 0) {
        console.log("%cĐÃ IN XONG TẤT CẢ ĐƠN BAR – SẴN SÀNG CHO ĐƠN TIẾP THEO", "color:#22c55e;font-size:14px;font-weight:bold;background:#166534;padding:4px 8px;border-radius:4px");
      }

      if (lastId === 0 && printData.length > 0) {
        const maxCurrent = Math.max(...printData.map(o => o.id));
        if (maxCurrent > 1000) setLast(maxCurrent);
      }

      isPrinting = false;
    };

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", printNewOrders);
    } else {
      printNewOrders();
    }
  </script>

  <!-- Auto refresh 5 giây (như cũ) -->
  <script>
    setInterval(() => location.reload(), 5000);
  </script>

  <!-- CSS NGUYÊN BẢN CỦA BẠN -->
  <style>
    /* Giữ nguyên 100% CSS cũ của bạn – không thay đổi gì */
    .page { min-height: 100vh; background: #020617; color: #e5e7eb; padding: 1.5rem; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; }
    .header { display: flex; justify-content: space-between; align-items: center; gap: 1rem; margin-bottom: 1rem; }
    .header h1 { margin: 0; font-size: 1.4rem; }
    .header p { margin: 0.2rem 0 0; font-size: 0.9rem; color: #9ca3af; }
    .status-box { display: inline-flex; align-items: center; gap: 0.4rem; padding: 0.4rem 0.8rem; border-radius: 999px; background: #0f172a; border: 1px solid #1f2937; font-size: 0.85rem; }
    .dot { width: 8px; height: 8px; border-radius: 999px; background: #22c55e; box-shadow: 0 0 8px rgba(34,197,94,0.7); }
    .main { margin-top: 0.5rem; }
    .no-orders { padding: 1.5rem; text-align: center; border-radius: 1rem; background: #0f172a; border: 1px dashed #1f2937; color: #9ca3af; }
    .orders-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 1rem; }
    .order-card { background: #020617; border-radius: 1rem; border: 1px solid #1f2937; padding: 0.9rem 1rem; box-shadow: 0 10px 25px rgba(0,0,0,0.6); }
    .order-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 0.75rem; margin-bottom: 0.5rem; }
    .order-header h2 { margin: 0; font-size: 1rem; }
    .order-meta { margin: 0.2rem 0 0; font-size: 0.8rem; color: #9ca3af; }
    .order-lines { list-style: none; padding: 0; margin: 0.4rem 0 0.6rem; font-size: 0.9rem; }
    .order-line { display: grid; grid-template-columns: 2rem minmax(0,1fr) 4rem; gap: 0.3rem; align-items: center; padding: 0.2rem 0; border-bottom: 1px dashed #111827; }
    .order-line:last-child { border-bottom: none; }
    .line-qty { font-weight: 600; color: #e5e7eb; }
    .line-name { color: #e5e7eb; }
    .line-price { text-align: right; font-size: 0.85rem; color: #a5b4fc; }
    .order-note-html { margin-top: 0.05rem; white-space: pre-wrap; color: #9ca3af; word-break: break-word; overflow-wrap: anywhere; line-height: 1.35; }
    .order-badge { background: #0f172a; color: #22c55e; border: 1px solid #22c55e; padding: 0.15rem 0.6rem; font-size: 0.7rem; font-weight: 700; border-radius: 999px; letter-spacing: 0.08em; white-space: nowrap; }
    @media (max-width: 640px) { .page { padding: 1rem; } .header { flex-direction: column; align-items: flex-start; } .orders-grid { grid-template-columns: 1fr; } }
  </style>
</Layout>